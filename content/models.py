# encoding: utf-8

from __future__ import print_function, unicode_literals

from collections import namedtuple

from django.conf import settings
from django.contrib.auth.models import User
from django.contrib.sites.models import Site
from django.core.mail import send_mail
from django.core.urlresolvers import reverse
from django.core.validators import RegexValidator
from django.db import models
from django.shortcuts import render
from django.utils.encoding import python_2_unicode_compatible
from django.utils.timezone import now
from django.template.loader import get_template

import bleach

from .utils import slugify, pick_attrs, format_emails, get_code


validate_slug = RegexValidator(
    regex=r'[a-z0-9-]+',
    message='Tekninen nimi saa sisältää vain pieniä kirjaimia, numeroita sekä väliviivoja.'
)

validate_path = RegexValidator(
    regex=r'[a-z0-9-/]+',
    message='Polku saa sisältää vain pieniä kirjaimia, numeroita, väliviivoja sekä kauttaviivoja.'
)


class CommonFields:
    path = dict(
        max_length=1023,
        validators=[validate_path],
        verbose_name='Polku',
        help_text='Polku määritetään automaattisesti teknisen nimen perusteella.',
    )

    slug = dict(
        blank=True, # actually not, but autogenerated anyway
        max_length=63,
        validators=[validate_slug],
        verbose_name='Tekninen nimi',
        help_text='Tekninen nimi eli "slug" näkyy URL-osoitteissa. Sallittuja '
            'merkkejä ovat pienet kirjaimet, numerot ja väliviiva. Jos jätät teknisen nimen tyhjäksi, '
            'se generoidaan automaattisesti otsikosta. Jos muutat teknistä nimeä julkaisun jälkeen, '
            'muista luoda tarvittavat uudelleenojaukset.',
    )

    title = dict(
        max_length=1023,
        verbose_name='Otsikko',
        help_text='Otsikko näytetään automaattisesti sivun ylälaidassa sekä valikossa. Älä lisää erillistä pääotsikkoa sivun tekstiin.',
    )

    body = dict(
        blank=True,
        verbose_name='Leipäteksti',
    )

    page_template = dict(
        max_length=127,
        verbose_name='Sivupohja',
        help_text='Sivut näytetään käyttäen tätä sivupohjaa. Tämännimisen sivupohjan tulee löytyä lähdekoodista.',
    )

    site = dict(
        verbose_name='Sivusto',
        help_text='Sivusto, jolle tämä sivu kuuluu. HUOM! Kun haluat luoda saman sivun toiselle sivustolle, älä siirrä vanhaa sivua vaan käytä sivunkopiointitoimintoa.',
    )

    public_from = dict(
        null=True,
        blank=True,
        verbose_name='Julkaisuaika',
        help_text='Sivu on tästä hetkestä alkaen myös sisäänkirjautumattomien käyttäjien luettavissa, jos nämä tietävät osoitteen. Jätä tyhjäksi, jos haluat jättää sivun luonnokseksi.',
    )

    visible_from = dict(
        null=True,
        blank=True,
        verbose_name='Näkyvissä alkaen',
        help_text='Sivu on tästä hetkestä alkaen näkyvissä valikossa tai listauksessa. Jätä tyhjäksi, jos haluat jättää sivun piilotetuksi.',
    )

    created_at = dict(
        auto_now_add=True,
        verbose_name='Luotu',
    )

    updated_at = dict(
        auto_now=True,
        verbose_name='Päivitetty',
    )


@python_2_unicode_compatible
class SiteSettings(models.Model):
    site = models.OneToOneField(Site,
        verbose_name='Sivusto',
        related_name='site_settings',
    )

    description = models.TextField(
        verbose_name='Sivuston kuvaus',
        help_text='Näkyy mm. hakukoneille sekä RSS-asiakasohjelmille.',
        blank=True,
        default='',
    )

    keywords = models.TextField(
        verbose_name='Sivuston avainsanat',
        help_text='Pilkuilla erotettu avainsanalista. Näkyy mm. hakukoneille.',
        blank=True,
        default='',
    )

    base_template = models.CharField(
        max_length=127,
        verbose_name='Asettelupohja',
        help_text='Asettelupohja määrittelee sivuston perusasettelun. Tämännimisen asettelupohjan tulee löytyä lähdekoodista.',
    )

    page_template = models.CharField(**CommonFields.page_template)

    blog_index_template = models.CharField(
        max_length=127,
        verbose_name='Blogilistauspohja',
        help_text='Blogilistaus näytetään käyttäen tätä sivupohjaa. Tämännimisen sivupohjan tulee löytyä lähdekoodista.',
    )

    blog_post_template = models.CharField(
        max_length=127,
        verbose_name='Blogipostauspohja',
        help_text='Blogipostaukset näytetään käyttäen tätä sivupohjaa. Tämännimisen sivupohjan tulee löytyä lähdekoodista.',
    )

    google_analytics_token = models.CharField(
        max_length=63,
        blank=True,
        verbose_name='Google Analytics -avain',
        help_text='Jos täytät tähän Google Analytics -sivustoavaimen, ei-kirjautuneiden käyttäjien visiitit raportoidaan Google Analyticsiin.',
    )

    context_processor_code = models.CharField(
        max_length=255,
        blank=True,
        default='',
        verbose_name='Sivustokontrolleri',
        help_text='Polku funktioon, joka suoritetaan joka sivulatauksella ja joka voi määritellä lisää muuttujia sivuston nimiavaruuteen.',
    )

    @classmethod
    def get_or_create_dummy(cls):
        site, unused = Site.objects.get_or_create(domain='example.com')

        return cls.objects.get_or_create(
            site=site,
            defaults=dict(
                title='Test site',
                base_template='tracon11_base.jade',
                page_template='tracon11_page.jade',
                blog_index_template='tracon11_blog_index.jade',
                blog_post_template='tracon11_blog_post.jade',
            )
        )

    @property
    def title(self):
        return self.site.name if self.site else None

    def get_menu(self, t=None, current_url=None, parent=None):
        if t is None:
            t = now()

        return [
            page.get_menu_entry(t=t, current_url=current_url)
            for page in Page.objects.filter(site=self.site, parent=parent, visible_from__lte=t).prefetch_related('child_page_set').all()
        ]

    def get_absolute_url(self):
        return '//{domain}'.format(domain=self.site.domain)

    def get_protocol_relative_uri(self, view_name, *args, **kwargs):
        return '//{domain}{path}'.format(
            domain=self.site.domain,
            path=reverse(view_name, args=args, kwargs=kwargs),
        )

    def get_visible_blog_posts(self, **extra_criteria):
        t = now()

        return self.site.blog_post_set.filter(visible_from__lte=t, **extra_criteria)

    def __str__(self):
        return self.site.domain if self.site else None

    class Meta:
        verbose_name = 'sivuston asetukset'
        verbose_name_plural = 'sivustojen asetukset'


BaseMenuEntry = namedtuple('MenuEntry', 'active href text children')
class MenuEntry(BaseMenuEntry):
    @property
    def active_css(self):
        return 'active' if self.active else ''


class RenderPageMixin(object):
    def render(self, request, **extra_vars):
        vars = dict(page=self)
        vars.update(extra_vars)

        return render(request, self.template, vars)


class PageAdminMixin(object):
    def admin_is_published(self):
        return self.public_from is not None
    admin_is_published.short_description = 'Julkinen'
    admin_is_published.boolean = True
    admin_is_published.admin_order_field = 'public_from'

    def admin_is_visible(self):
        return self.visible_from is not None
    admin_is_visible.short_description = 'Näkyvissä'
    admin_is_visible.boolean = True
    admin_is_visible.admin_order_field = 'visible_from'


@python_2_unicode_compatible
class Page(models.Model, RenderPageMixin, PageAdminMixin):
    site = models.ForeignKey(Site, **CommonFields.site)
    path = models.CharField(**CommonFields.path)
    parent = models.ForeignKey('Page',
        null=True,
        blank=True,
        verbose_name='Yläsivu',
        help_text='Jos valitset tähän sivun, tämä sivu luodaan valitun sivun alaisuuteen. Jos jätät tämän tyhjäksi, sivu luodaan päätasolle.',
        related_name='child_page_set',
    )

    slug = models.CharField(**CommonFields.slug)

    created_at = models.DateTimeField(**CommonFields.created_at)
    updated_at = models.DateTimeField(**CommonFields.updated_at)
    public_from = models.DateTimeField(**CommonFields.public_from)
    visible_from = models.DateTimeField(**CommonFields.visible_from)

    title = models.CharField(**CommonFields.title)
    override_menu_text = models.CharField(
        max_length=1023,
        blank=True,
        verbose_name='Valikkoteksti',
        help_text='Sivu näkyy tällä nimellä valikossa. Jos jätät tämän tyhjäksi, käytetään otsikkoa.',
    )
    override_page_template = models.CharField(blank=True, default='', **CommonFields.page_template)
    page_controller_code = models.CharField(
        max_length=255,
        blank=True,
        default='',
        verbose_name='Sivukontrolleri',
        help_text='Polku funktioon, joka suoritetaan joka sivulatauksella ja joka voi määritellä lisää muuttujia sivupohjan nimiavaruuteen.',
    )
    order = models.IntegerField(
        default=0,
        verbose_name='Järjestys',
        help_text='Saman yläsivun alaiset sivut järjestetään valikossa tämän luvun mukaan nousevaan '
            'järjestykseen (pienin ensin).'
    )
    body = models.TextField(**CommonFields.body)

    header_image = models.FileField(
        verbose_name='Otsikkokuva',
        help_text='Näytetään sivun ylälaidassa, jos käytettävä teema tukee tätä. Mikäli otsikkokuvaa ei ole asetettu, käytetään yläsivun otsikkokuvaa.',
        upload_to='headers',
        blank=True,
    )

    @property
    def some_header_image(self):
        if self.header_image:
            return self.header_image
        elif self.parent:
            return self.parent.some_header_image
        else:
            return None

    @property
    def edit_link(self):
        return reverse('admin:content_page_change', args=(self.id,))

    @property
    def menu_text(self):
        if self.override_menu_text:
            return self.override_menu_text
        else:
            return self.title

    @property
    def template(self):
        if self.override_page_template:
            return self.override_page_template
        else:
            return self.site.site_settings.page_template

    @property
    def is_front_page(self):
        return self.parent is None and self.slug == 'front-page'

    def get_absolute_url(self):
        return u'//{domain}/{path}'.format(
            domain=self.site.domain,
            path='' if self.is_front_page else self.path,

        )

    def get_local_url(self):
        return u'/' if self.is_front_page else u'/' + self.path

    def get_menu_entry(self, child_levels=1, t=None, current_url=None):
        # Guard against infinite recursion on parent loop and prevent lots of queries on default 2-level menu structure
        if child_levels > 0:
            children = [
                child_page.get_menu_entry(
                    child_levels=child_levels - 1,
                    t=t,
                    current_url=current_url,
                )

                # TODO check if this hits the prefetch
                for child_page in self.child_page_set.filter(visible_from__lte=t)
            ]
        else:
            children = []

        href = self.get_local_url()

        if current_url:
            if children:
                active = current_url.startswith(href)
            else:
                active = current_url == href
        else:
            active = False

        return MenuEntry(
            active=active,
            href=href,
            text=self.menu_text,
            children=children,
        )

    def as_dict(self):
        return pick_attrs(self,
            'path',
            'title',
            'override_menu_text',
            'body',
            'order',
            public_from=self.public_from.isoformat() if self.public_from else None,
            visible_from=self.visible_from.isoformat() if self.visible_from else None,
            created_at=self.created_at.isoformat() if self.created_at else None,
            updated_at=self.updated_at.isoformat() if self.updated_at else None,
        )

    def get_parent_path(self):
        assert self.path
        return u'/'.join(self.path.split('/')[:-1])

    def copy_to_site(self, site, **extra_keys):
        parent_path = self.get_parent_path()
        if parent_path:
            parent = Page.objects.get(site=site, path=parent_path)
        else:
            parent = None

        page_copy_attrs = dict(site=site, parent=parent)
        page_copy_attrs.update((key, getattr(self, key)) for key in Page.copy_to_site.fields_to_set)
        page_copy_attrs.update(extra_keys)

        original_slug = page_copy_attrs['slug']
        if Page.objects.filter(site=site, parent=parent, slug=page_copy_attrs['slug']).exists():
            counter = 0
            while True:
                counter += 1
                page_copy_attrs['slug'] = "{original_slug}-copy-{counter}".format(original_slug=original_slug, counter=counter)
                if not Page.objects.filter(site=site, parent=parent, slug=page_copy_attrs['slug']).exists():
                    break

        page_copy = Page(**page_copy_attrs)
        page_copy.save()

        return page_copy
    copy_to_site.fields_to_set = [
        'slug',
        'title',
        'override_menu_text',
        'body',
        'order',
    ]

    def render(self, request, **extra_vars):
        if self.page_controller_code:
            page_controller_func = get_code(self.page_controller_code)
            extra_vars.update(page_controller_func(request, self))

        return super(Page, self).render(request, **extra_vars)

    def _make_path(self):
        if self.parent is None:
            return self.slug
        else:
            return self.parent.path + '/' + self.slug

    def save(self, *args, **kwargs):
        if self.title and not self.slug:
            self.slug = slugify(self.title)

        if self.slug:
            self.path = self._make_path()

        return_value = super(Page, self).save(*args, **kwargs)

        # In case path changed, update child pages' paths.
        # TODO prevent parent loop in somewhere else
        for child_page in self.child_page_set.all():
            child_page.save()

    def __str__(self):
        return u'{title} ({site})'.format(title=self.title, site=self.site)

    class Meta:
        verbose_name = 'sivu'
        verbose_name_plural = 'sivut'
        unique_together = [('site', 'path'), ('site', 'parent', 'slug')]

        # Usually searches are filtered by site and parent, so we skip them from the ordering.
        ordering = ('order',)


@python_2_unicode_compatible
class Redirect(models.Model):
    site = models.ForeignKey(Site)
    path = models.CharField(**CommonFields.path)
    target = models.CharField(max_length=1023)

    def __str__(self):
        return self.path

    class Meta:
        unique_together = [('site', 'path')]
        verbose_name = 'uudelleenohjaus'
        verbose_name_plural = 'uudelleenohjaukset'


@python_2_unicode_compatible
class BlogCategory(models.Model):
    site = models.ForeignKey(Site, verbose_name='Sivusto')
    slug = models.CharField(**CommonFields.slug)
    title = models.CharField(**CommonFields.title)

    def get_visible_blog_posts(self):
        return self.blog_posts.filter(visible_from__lte=now())

    @property
    def path(self):
        return reverse("content_blog_category_index_view", args=(self.slug,))[1:] # remove leading /

    def get_absolute_url(self):
        return u'//{domain}/{path}'.format(
            domain=self.site.domain,
            path=self.path,
        )

    def __str__(self):
        return u'{title} ({domain})'.format(
            title=self.title,
            domain=self.site.domain if self.site else None,
        )

    def save(self, *args, **kwargs):
        if self.title and not self.slug:
            self.slug = slugify(self.title)

        return super(BlogCategory, self).save(*args, **kwargs)

    class Meta:
        verbose_name = 'Blogin kategoria'
        verbose_name_plural = 'Blogin kategoriat'

        unique_together = [('site', 'slug')]


STATE_CHOICES = [
    ('draft', u'Luonnos'),
    ('review', u'Odottaa tarkistusta'),
    ('ready', u'Valmis julkaistavaksi'),
]


@python_2_unicode_compatible
class BlogPost(models.Model, RenderPageMixin, PageAdminMixin):
    site = models.ForeignKey(Site, related_name='blog_post_set', **CommonFields.site)
    path = models.CharField(**CommonFields.path)
    date = models.DateField(
        blank=True,
        verbose_name='Päivämäärä',
        help_text='Päivämäärä on osa postauksen osoitetta. Älä muuta päivämäärää julkaisun jälkeen. '
            'Jos jätät kentän tyhjäksi, siihen valitaan tämä päivä.',
    )
    slug = models.CharField(**CommonFields.slug)
    author = models.ForeignKey(User,
        null=True,
        blank=True,
        verbose_name='Tekijä',
        help_text='Jos jätät kentän tyhjäksi, tekijäksi asetetaan automaattisesti sinut.',
    )

    state = models.CharField(
        max_length=7,
        default='draft',
        choices=STATE_CHOICES,
        verbose_name='Luonnoksen tila',
        help_text='Tämä kenttä kommunikoi muille julkaisujärjestelmän käyttäjille, onko sivu '
            'kirjoittajan mielestä valmis julkaistavaksi. Jos et itse julkaise kirjoitustasi, '
            'jätä kirjoituksesi tilaan "Odottaa tarkistusta" kun se on mielestäsi valmis. Tämä '
            'kenttä ei vaikuta teknisesti kirjoituksen julkaisuun millään tavalla.'
    )
    internal_notes = models.TextField(
        blank=True,
        verbose_name='Sisäiset muistiinpanot',
        help_text='Tähän kenttään voit jättää muistiinpanoja itsellesi ja muille julkaisujärjestelmän '
            'käyttäjille esimerkiksi suunnittelemastasi sisällöstä tai kirjoituksen julkaisuaikataulusta. '
            'Nämä muistiinpanot eivät näy ulospäin, vaan ne on tarkoitettu puhtaasti julkaisujärjestelmän '
            'toimittaja- ja ylläpitokäyttäjien tiedoksi.'
    )

    created_at = models.DateTimeField(**CommonFields.created_at)
    updated_at = models.DateTimeField(**CommonFields.updated_at)
    public_from = models.DateTimeField(**CommonFields.public_from)
    visible_from = models.DateTimeField(**CommonFields.visible_from)

    title = models.CharField(**CommonFields.title)
    body = models.TextField(**CommonFields.body)
    override_excerpt = models.TextField(
        verbose_name='Lyhennelmä',
        blank=True,
        default='',
        help_text='Kirjoita muutaman lauseen mittainen lyhennelmä kirjoituksesta. Lyhennelmä näkyy '
            'blogilistauksessa. Mikäli lyhennelmää ei ole annettu, leikataan lyhennelmäksi sopivan '
            'mittainen pätkä itse kirjoituksesta.',
    )

    categories = models.ManyToManyField(BlogCategory,
        verbose_name='Kategoriat',
        blank=True,
        related_name='blog_posts',
        help_text='Voit halutessasi lisätä postauksen yhteen tai useampaan kategoriaan. Kaikkien valittujen '
            'kategorioiden tulee olla samalla sivustolla postauksen kanssa.',
    )
    is_featured = models.BooleanField(
        default=False,
        verbose_name='Korosta postausta',
        help_text='Korostetut postaukset näkyvät sitä tukevilla sivustoilla näyttävämmin.',
    )

    @property
    def edit_link(self):
        return reverse('admin:content_blogpost_change', args=(self.id,))

    @property
    def excerpt(self):
        max_chars = settings.TRACONTENT_BLOG_AUTO_EXCERPT_MAX_CHARS

        if self.override_excerpt:
            return self.override_excerpt
        else:
            plain_text = bleach.clean(self.body, tags=[], strip=True)
            if len(plain_text) <= max_chars:
                return plain_text
            else:
                return plain_text[:max_chars] + u'…'

    @property
    def template(self):
        return self.site.site_settings.blog_post_template

    @property
    def featured_css(self):
        return 'featured' if self.is_featured else ''

    @property
    def formatted_author(self):
        if self.author:
            if 'users' in settings.INSTALLED_APPS:
                from users.models import UserMeta
                return UserMeta.get_for_user(self.author).get_full_name()
            else:
                return self.author.get_full_name()
        else:
            return ''

    @property
    def categories_html(self):
        return u', '.join(
            '<a href="{href}">{title}</a>'.format(
                href=category.get_absolute_url(),
                title=category.title,
            ) for category in self.categories.all()
        )

    def get_absolute_url(self):
        return u'//{domain}/{path}'.format(
            domain=self.site.domain,
            path=self.path,
        )

    def get_comments(self):
        return self.blog_comment_set.filter(removed_at__isnull=True)

    def _make_path(self):
        return reverse('content_blog_post_view', kwargs=dict(
            year=self.date.year,
            month="{:02d}".format(self.date.month),
            day="{:02d}".format(self.date.day),
            slug=self.slug,
        ))[1:] # remove leading /

    def save(self, *args, **kwargs):
        if self.title and not self.slug:
            self.slug = slugify(self.title)

        if self.date and self.slug:
            self.path = self._make_path()

        return super(BlogPost, self).save(*args, **kwargs)

    def __str__(self):
        return self.title

    class Meta:
        verbose_name = 'blogipostaus'
        verbose_name_plural = 'blogipostaukset'
        unique_together = [('site', 'path'), ('site', 'date', 'slug')]

        # Usually queries are filtered by site, so we skip it from the ordering.
        ordering = ('-date', '-public_from')


@python_2_unicode_compatible
class BlogComment(models.Model):
    blog_post = models.ForeignKey(BlogPost, verbose_name='Blogipostaus', db_index=True, related_name='blog_comment_set')
    author_name = models.CharField(
        max_length=1023,
        verbose_name='Nimi tai nimimerkki',
        help_text='Näkyy muille sivun lukijoille.',
    )
    author_email = models.EmailField(
        verbose_name='Sähköpostiosoite',
        help_text='Sähköpostiosoitetta ei julkaista.',
    )
    author_ip_address = models.CharField(
        max_length=17,
        blank=True,
        verbose_name='IP-osoite',
        help_text='IP-osoite näkyy vain ylläpitokäyttöliittymässä.',
    )

    comment = models.TextField(
        verbose_name='Kommentti',
        help_text='Pidetään keskustelu ystävällisenä, asiallisena ja muita kunnioittavana. Ylläpito poistaa asiattomat kommentit.',
    )

    created_at = models.DateTimeField(**CommonFields.created_at)
    removed_at = models.DateTimeField(
        null=True,
        blank=True,
        verbose_name='Piilottamisaika',
    )
    removed_by = models.ForeignKey(User,
        null=True,
        blank=True,
        verbose_name='Piilottaja',
    )

    def admin_get_site(self):
        return self.blog_post.site
    admin_get_site.short_description = 'Sivusto'
    admin_get_site.admin_order_field = 'blog_post__site'

    @property
    def excerpt(self):
        if self.comment and len(self.comment) > BlogComment.admin_get_excerpt.max_length:
            return self.comment[:BlogComment.admin_get_excerpt.max_length] + u'…'
        else:
            return self.comment

    # Cannot set admin metadata on property object
    def admin_get_excerpt(self):
        return self.excerpt
    admin_get_excerpt.max_length = 100
    admin_get_excerpt.short_description = 'Kommentti (lyhennetty)'

    @property
    def is_active(self):
        return self.removed_at is None

    def admin_is_active(self):
        return self.is_active
    admin_is_active.short_description = 'Näkyvissä'
    admin_is_active.boolean = True
    admin_is_active.admin_order_field = 'removed_at'

    def get_absolute_url(self):
        return self.blog_post.get_absolute_url() + u'#comment-{id}'.format(id=self.id)

    @property
    def edit_link(self):
        return reverse('admin:content_blogcomment_change', args=(self.id,))

    def send_mail_to_moderators(self, request):
        subject = "{site_title}: Uusi blogikommentti".format(site_title=request.site.site_settings.title)
        body = get_template('content_email_blog_new_comment.eml').render(dict(
            site_settings=request.site.site_settings,
            blog_comment=self,
            settings=settings,
            comment_url=request.build_absolute_uri(self.get_absolute_url()),
            moderation_url=request.build_absolute_uri(self.edit_link),
        ), request)

        if settings.DEBUG:
            print(body)

        if settings.TRACONTENT_BLOG_COMMENT_MODERATORS:
            send_mail(
                subject=subject,
                message=body,
                from_email=settings.DEFAULT_FROM_EMAIL,
                recipient_list=format_emails(settings.TRACONTENT_BLOG_COMMENT_MODERATORS),
            )

    def __str__(self):
        return self.excerpt

    class Meta:
        verbose_name = 'blogikommentti'
        verbose_name_plural = 'blogikommentit'
        ordering = ('created_at',)
        index_together = [('blog_post', 'removed_at')]
